#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "message.h"
#include <sys/socket.h>
#include <netinet/in.h>
void Escribir_Puerto (int puerto);

/* FUNCION MAIN DEL PROGRAMA SERVIDOR */
int main(int argc,char* argv[])
{
  socklen_t size1,size2,size3,size4;
  int sd_UDP, sd_TCP, cd, fd, tam;
  struct sockaddr_in strUDP, strTCP, c_ain, c2_ain;
  char buffer[512];
  UDP_Msg msg1, msg2;
    /* El esqueleto de la funcion principal muestra, de forma esquematica la secuencia 
       de operaciones y la correspondiente traza que se sugiere */

  /* Creacion del socket UDP */
  
  sd_UDP=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
  if(sd_UDP==-1){
    fprintf(stdout,"SERVIDOR: Creacion del socket UDP: ERROR\n");
  }
  else{
    fprintf(stdout,"SERVIDOR: Creacion del socket UDP: OK\n");
  }
  /* Asignacion de la direccion local (del servidor) Puerto UDP*/
  bzero((char *)&strUDP, sizeof(strUDP));
  strUDP.sin_family=AF_INET;
  strUDP.sin_addr.s_addr=INADDR_ANY;
  strUDP.sin_port=htonl(0);
  if( bind(sd_UDP,(struct sockaddr *)&strUDP, sizeof(strUDP))!=-1){
    fprintf(stdout,"SERVIDOR: Asignacion del puerto servidor: OK\n");
  }
  else{
    fprintf(stdout,"SERVIDOR: Asignacion del puerto servidor: ERROR\n");
  }
  /* Escribimos el puerto de servicio */
  size1=sizeof(strUDP);
  getsockname(sd_UDP,(struct sockaddr *)&strUDP, &size1);
  Escribir_Puerto(ntohs(strUDP.sin_port));
    
  /* Creacion del socket TCP de servicio */
  sd_TCP=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
  if(sd_TCP==-1){
    fprintf(stdout,"SERVIDOR: Creacion del socket TCP: ERROR\n");
  }
  else{
    fprintf(stdout,"SERVIDOR: Creacion del socket TCP: OK\n");
  }
  /* Asignacion de la direccion local (del servidor) Puerto TCP*/
  bzero((char *)&strTCP, sizeof(strTCP));
  strTCP.sin_family=AF_INET;
  strTCP.sin_addr.s_addr=INADDR_ANY;
  strTCP.sin_port=htonl(0);
  if(bind(sd_TCP,(struct sockaddr *)&strTCP, sizeof(strTCP))!=-1){
    fprintf(stdout,"SERVIDOR: Asignacion del puerto servidor: OK\n");
  }
  else{
    fprintf(stdout,"SERVIDOR: Asignacion del puerto servidor: ERROR\n");
    close(sd_UDP);
    close(sd_TCP);
    exit(1);
  }
  /* Aceptamos conexiones por el socket */
  if(listen(sd_TCP,5)==0){
    fprintf(stdout,"SERVIDOR: Aceptacion de peticiones: OK\n");
  }
  else{
    fprintf(stdout,"SERVIDOR: Aceptacion de peticiones: ERROR\n");
    close(sd_TCP);
    close(sd_UDP);
    exit(1);
  }
  /* Puerto TCP ya disponible */
  fprintf(stdout,"SERVIDOR: Puerto TCP reservado: OK\n");
  
  while(1 /* Bucle de procesar peticiones */)
    { 
      fprintf(stdout,"SERVIDOR: Esperando mensaje.\n");
      /* Recibo mensaje */
      size3=sizeof(c_ain);
      if(recvfrom(sd_UDP,&msg1,sizeof(msg1),0,(struct sockaddr *)&c_ain,&size3)==-1){	
	fprintf(stdout,"SERVIDOR: Mensaje del cliente: ERROR\n");
	msg2.op=htonl(ERROR);
	sendto(sd_UDP,&msg2,sizeof(msg2),0,(struct sockaddr *)&c_ain,size3);
	//close(sd_UDP);
	//close(sd_TCP);
	//exit(1);
	continue;
      }
      else{
	fprintf(stdout,"SERVIDOR: Mensaje del cliente: OK\n");
      }
      
      if(ntohl(msg1.op)==QUIT){
	  fprintf(stdout,"SERVIDOR: QUIT\n");
	  fprintf(stdout,"SERVIDOR: Enviando del resultado [OK]: OK\n");
	  msg2.op=htonl(OK);
	  sendto(sd_UDP,&msg2,sizeof(msg2),0,(struct sockaddr *)&c_ain,size3);
	  //  close(sd_UDP);
	  // close(sd_TCP);
	  break;
      }
      //Quizas comprobar si msg1.op=REQUEST
      else
      {
	
	  fprintf(stdout,"SERVIDOR: REQUEST(%s,%s)\n", msg1.local, msg1.remoto);
	  
	  /* Envio del resultado */
	  if((fd=open(msg1.remoto,O_RDONLY))<0){
	    msg2.op=htonl(ERROR);
	    if((sendto(sd_UDP,&msg2,sizeof(msg2),0,(struct sockaddr *)&c_ain,size3))<0){
	      fprintf(stdout,"SERVIDOR: Enviando del resultado [ERROR]: ERROR\n");
	      continue;
	    }
	    else{
	      fprintf(stdout,"SERVIDOR: Enviando del resultado [ERROR]: OK\n");
	    }
	    
	    //close(sd_UDP);
	    //close(sd_TCP);
	    //exit(1);
	    continue;
	  }
	  else{
	    msg2.op=htonl(OK);
	    size2=sizeof(strTCP);
	    getsockname(sd_TCP,(struct sockaddr *)&strTCP, &size2);
	    msg2.puerto=strTCP.sin_port;
	    if((sendto(sd_UDP,&msg2,sizeof(msg2),0,(struct sockaddr *)&c_ain,size3))<0){
	      fprintf(stdout,"SERVIDOR: Enviando del resultado [OK]: ERROR\n");
	    }
	    else{
	      fprintf(stdout,"SERVIDOR: Enviando del resultado [OK]: OK\n");
	    }	    
	  }


	  /* Esperamos la llegada de una conexion */
	  size4=sizeof(c2_ain);
	  if((cd=accept(sd_TCP,(struct sockaddr *)&c2_ain,&size4))<0){
	     fprintf(stdout,"SERVIDOR: Llegada de un mensaje: ERROR\n");
	     //close(sd_UDP);
	     //close(sd_TCP);
	     //close(fd);
	     //     exit(1);
	     continue;
	    }
	  else{
	    fprintf(stdout,"SERVIDOR: Llegada de un mensaje: OK\n");
	    //close(sd_TCP);
	    //while(tam=read(fd,buffer,512 bytes))=>write(socketFD(nuevo),buffer,tamaÃ±o)
	    while((tam=read(fd,buffer,512))>0){	    
	      send(cd,buffer,tam,0);
	    }	    
	    close(cd);
	    close(fd);
	  }       
      }
    }
  close(sd_TCP);	   
  close(sd_UDP);
  fprintf(stdout,"SERVIDOR: Finalizado\n");
  exit(0);
}

/* Funcion auxiliar que escribe un numero de puerto en el fichero */
void Escribir_Puerto (int puerto)
    {
    int fd;
    if((fd=creat(FICHERO_PUERTO,0660))>=0)
      {
	write(fd,&puerto,sizeof(int));
	close(fd);
	fprintf(stdout,"SERVIDOR: Puerto guardado en fichero %s: OK\n",FICHERO_PUERTO);
    }
}



